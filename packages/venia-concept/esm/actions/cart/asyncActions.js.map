{"version":3,"sources":["../../../src/actions/cart/asyncActions.js"],"names":["RestApi","Util","closeDrawer","toggleDrawer","checkoutActions","actions","request","Magento2","BrowserPersistence","storage","createCart","thunk","dispatch","getState","cart","user","cartId","reset","getCart","retrieveCartId","isSignedIn","receive","guestCartEndpoint","signedInCartEndpoint","cartEndpoint","method","saveCartId","body","JSON","stringify","address","error","addItemToCart","payload","item","quantity","writingImageToCache","writeImageToCache","addItem","missingCartIdError","Error","noCartId","cartItem","toRESTCartItem","response","getCartDetails","forceRefresh","status","removeCart","arguments","updateItemInCart","targetItemId","updateItem","closeOptionsDrawer","removeItemFromCart","removeItem","item_id","cartItemCount","details","items_count","clearCartId","openOptionsDrawer","getDetails","imageCache","paymentMethods","totals","Promise","all","retrieveImageCache","fetchCartPart","subResource","items","Array","isArray","length","validTotals","forEach","image","sku","options","matchingItem","find","t","parse","toggleCart","app","drawer","signedInEndpoint","guestEndpoint","endpoint","cache","getCartId","getItem","id","setItem","saveImageCache","productType","qty","name","quote_id","parentSku","product_type","product_option","extension_attributes","configurable_item_options","media_gallery_entries","media","m","position"],"mappings":"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","sourcesContent":["import { RestApi, Util } from '@magento/peregrine';\n\nimport { closeDrawer, toggleDrawer } from 'src/actions/app';\nimport checkoutActions from 'src/actions/checkout';\nimport actions from './actions';\n\nconst { request } = RestApi.Magento2;\nconst { BrowserPersistence } = Util;\nconst storage = new BrowserPersistence();\n\nexport const createCart = () =>\n    async function thunk(dispatch, getState) {\n        const { cart, user } = getState();\n\n        // if a cart already exists in the store, exit\n        if (cart.cartId) {\n            return;\n        }\n\n        // reset the checkout workflow\n        // in case the user has already completed an order this session\n        dispatch(checkoutActions.reset());\n\n        // Request a new cart.\n        dispatch(actions.getCart.request());\n\n        // if a cart exists in storage, act like we just received it\n        const cartId = await retrieveCartId();\n        if (cartId && !user.isSignedIn) {\n            dispatch(actions.getCart.receive(cartId));\n            return;\n        }\n\n        try {\n            const guestCartEndpoint = '/rest/V1/guest-carts';\n            const signedInCartEndpoint = '/rest/V1/carts/mine';\n            const cartEndpoint = user.isSignedIn\n                ? signedInCartEndpoint\n                : guestCartEndpoint;\n\n            const cartId = await request(cartEndpoint, {\n                method: 'POST'\n            });\n\n            // write to storage in the background\n            saveCartId(cartId);\n\n            // There is currently an issue in Magento 2\n            // where the first item added to an empty cart for an\n            // authenticated customer gets added with a price of zero.\n            // @see https://github.com/magento/magento2/issues/2991\n            // This workaround is in place until that issue is resolved.\n            if (user.isSignedIn) {\n                await request('/rest/V1/carts/mine/billing-address', {\n                    method: 'POST',\n                    body: JSON.stringify({\n                        address: {},\n                        cartId\n                    })\n                });\n            }\n\n            dispatch(actions.getCart.receive(cartId));\n        } catch (error) {\n            dispatch(actions.getCart.receive(error));\n        }\n    };\n\nexport const addItemToCart = (payload = {}) => {\n    const { item, quantity } = payload;\n    const writingImageToCache = writeImageToCache(item);\n\n    return async function thunk(dispatch, getState) {\n        await writingImageToCache;\n        dispatch(actions.addItem.request(payload));\n\n        try {\n            const { cart, user } = getState();\n            const { cartId } = cart;\n\n            if (!cartId) {\n                const missingCartIdError = new Error(\n                    'Missing required information: cartId'\n                );\n                missingCartIdError.noCartId = true;\n                throw missingCartIdError;\n            }\n\n            const cartItem = toRESTCartItem(cartId, payload);\n\n            const { isSignedIn } = user;\n            const guestCartEndpoint = `/rest/V1/guest-carts/${cartId}/items`;\n            const signedInCartEndpoint = '/rest/V1/carts/mine/items';\n            const cartEndpoint = isSignedIn\n                ? signedInCartEndpoint\n                : guestCartEndpoint;\n\n            const response = await request(cartEndpoint, {\n                method: 'POST',\n                body: JSON.stringify({ cartItem })\n            });\n\n            // 2019-02-07  Moved these dispatches to the success clause of\n            // addItemToCart. The cart should only open on success.\n            // In the catch clause, this action creator calls its own thunk,\n            // so a successful retry will wind up here anyway.\n            await dispatch(getCartDetails({ forceRefresh: true }));\n            await dispatch(toggleDrawer('cart'));\n            dispatch(\n                actions.addItem.receive({ cartItem: response, item, quantity })\n            );\n        } catch (error) {\n            const { response, noCartId } = error;\n\n            dispatch(actions.addItem.receive(error));\n\n            // check if the cart has expired\n            if (noCartId || (response && response.status === 404)) {\n                // Delete the cached ID from local storage and Redux.\n                // In contrast to the save, make sure storage deletion is\n                // complete before dispatching the error--you don't want an\n                // upstream action to try and reuse the known-bad ID.\n                await dispatch(removeCart());\n                // then create a new one\n                await dispatch(createCart());\n                // then retry this operation\n                return thunk(...arguments);\n            }\n        }\n    };\n};\n\nexport const updateItemInCart = (payload = {}, targetItemId) => {\n    const { item, quantity } = payload;\n    const writingImageToCache = writeImageToCache(item);\n\n    return async function thunk(dispatch, getState) {\n        await writingImageToCache;\n        dispatch(actions.updateItem.request(payload));\n\n        const { cart, user } = getState();\n\n        try {\n            const { cartId } = cart;\n\n            if (!cartId) {\n                const missingCartIdError = new Error(\n                    'Missing required information: cartId'\n                );\n                missingCartIdError.noCartId = true;\n                throw missingCartIdError;\n            }\n\n            const cartItem = toRESTCartItem(cartId, payload);\n\n            const { isSignedIn } = user;\n            const guestCartEndpoint = `/rest/V1/guest-carts/${cartId}/items/${targetItemId}`;\n            const signedInCartEndpoint = `/rest/V1/carts/mine/items/${targetItemId}`;\n            const cartEndpoint = isSignedIn\n                ? signedInCartEndpoint\n                : guestCartEndpoint;\n\n            const response = await request(cartEndpoint, {\n                method: 'PUT',\n                body: JSON.stringify({ cartItem })\n            });\n\n            dispatch(\n                actions.updateItem.receive({\n                    cartItem: response,\n                    item,\n                    quantity\n                })\n            );\n        } catch (error) {\n            const { response, noCartId } = error;\n\n            dispatch(actions.updateItem.receive(error));\n\n            // check if the cart has expired\n            if (noCartId || (response && response.status === 404)) {\n                // Delete the cached ID from local storage and Redux.\n                // In contrast to the save, make sure storage deletion is\n                // complete before dispatching the error--you don't want an\n                // upstream action to try and reuse the known-bad ID.\n                await dispatch(removeCart());\n                // then create a new one\n                await dispatch(createCart());\n\n                if (user.isSignedIn) {\n                    // The user is signed in and we just received their cart.\n                    // Retry this operation.\n                    return thunk(...arguments);\n                } else {\n                    // The user is a guest and just received a brand new (empty) cart.\n                    // Add the updated item to that cart.\n                    await dispatch(addItemToCart(payload));\n                }\n            }\n        }\n\n        await dispatch(getCartDetails({ forceRefresh: true }));\n\n        // Close the options drawer only after the cart is finished updating.\n        dispatch(closeOptionsDrawer());\n    };\n};\n\nexport const removeItemFromCart = payload => {\n    const { item } = payload;\n\n    return async function thunk(dispatch, getState) {\n        dispatch(actions.removeItem.request(payload));\n\n        const { cart, user } = getState();\n\n        try {\n            const { cartId } = cart;\n\n            if (!cartId) {\n                const missingCartIdError = new Error(\n                    'Missing required information: cartId'\n                );\n                missingCartIdError.noCartId = true;\n                throw missingCartIdError;\n            }\n\n            const { isSignedIn } = user;\n            const guestCartEndpoint = `/rest/V1/guest-carts/${cartId}/items/${\n                item.item_id\n            }`;\n            const signedInCartEndpoint = `/rest/V1/carts/mine/items/${\n                item.item_id\n            }`;\n            const cartEndpoint = isSignedIn\n                ? signedInCartEndpoint\n                : guestCartEndpoint;\n\n            const response = await request(cartEndpoint, {\n                method: 'DELETE'\n            });\n\n            // When removing the last item in the cart, perform a reset\n            // to prevent a bug where the next item added to the cart has\n            // a price of 0\n            const cartItemCount = cart.details ? cart.details.items_count : 0;\n            if (cartItemCount === 1) {\n                await clearCartId();\n            }\n\n            dispatch(\n                actions.removeItem.receive({\n                    cartItem: response,\n                    item,\n                    cartItemCount\n                })\n            );\n        } catch (error) {\n            const { response, noCartId } = error;\n\n            dispatch(actions.removeItem.receive(error));\n\n            // check if the cart has expired\n            if (noCartId || (response && response.status === 404)) {\n                // Delete the cached ID from local storage.\n                // The reducer handles clearing out the bad ID from Redux.\n                // In contrast to the save, make sure storage deletion is\n                // complete before dispatching the error--you don't want an\n                // upstream action to try and reuse the known-bad ID.\n                await clearCartId();\n                // then create a new one\n                await dispatch(createCart());\n\n                if (user.isSignedIn) {\n                    // The user is signed in and we just received their cart.\n                    // Retry this operation.\n                    return thunk(...arguments);\n                }\n\n                // Else the user is a guest and just received a brand new (empty) cart.\n                // We don't retry because we'd be attempting to remove an item\n                // from an empty cart.\n            }\n        }\n\n        await dispatch(getCartDetails({ forceRefresh: true }));\n    };\n};\n\nexport const openOptionsDrawer = () => async dispatch =>\n    dispatch(actions.openOptionsDrawer());\n\nexport const closeOptionsDrawer = () => async dispatch =>\n    dispatch(actions.closeOptionsDrawer());\n\nexport const getCartDetails = (payload = {}) => {\n    const { forceRefresh } = payload;\n\n    return async function thunk(dispatch, getState) {\n        const { cart, user } = getState();\n        const { cartId } = cart;\n        const { isSignedIn } = user;\n\n        // if there isn't a cart, create one\n        // then retry this operation\n        if (!cartId) {\n            await dispatch(createCart());\n            return thunk(...arguments);\n        }\n\n        // Once we have the cart id indicate that we are starting to make\n        // async requests for the details.\n        dispatch(actions.getDetails.request(cartId));\n\n        try {\n            const [\n                imageCache,\n                details,\n                paymentMethods,\n                totals\n            ] = await Promise.all([\n                retrieveImageCache(),\n                fetchCartPart({\n                    cartId,\n                    forceRefresh,\n                    isSignedIn\n                }),\n                fetchCartPart({\n                    cartId,\n                    forceRefresh,\n                    isSignedIn,\n                    subResource: 'payment-methods'\n                }),\n                fetchCartPart({\n                    cartId,\n                    forceRefresh,\n                    isSignedIn,\n                    subResource: 'totals'\n                })\n            ]);\n\n            const { items } = details;\n\n            // for each item in the cart, look up its image in the cache\n            // and merge it into the item object\n            // then assign its options from the totals subResource\n            if (imageCache && Array.isArray(items) && items.length) {\n                const validTotals = totals && totals.items;\n                items.forEach(item => {\n                    item.image = item.image || imageCache[item.sku] || {};\n\n                    let options = [];\n                    if (validTotals) {\n                        const matchingItem = totals.items.find(\n                            t => t.item_id === item.item_id\n                        );\n                        if (matchingItem && matchingItem.options) {\n                            options = JSON.parse(matchingItem.options);\n                        }\n                    }\n                    item.options = options;\n                });\n            }\n\n            dispatch(\n                actions.getDetails.receive({ details, paymentMethods, totals })\n            );\n        } catch (error) {\n            const { response } = error;\n\n            dispatch(actions.getDetails.receive(error));\n\n            // check if the cart has expired\n            if (response && response.status === 404) {\n                // if so, then delete the cached ID from local storage.\n                // The reducer handles clearing out the bad ID from Redux.\n                // In contrast to the save, make sure storage deletion is\n                // complete before dispatching the error--you don't want an\n                // upstream action to try and reuse the known-bad ID.\n                await clearCartId();\n                // then create a new one\n                await dispatch(createCart());\n                // then retry this operation\n                return thunk(...arguments);\n            }\n        }\n    };\n};\n\nexport const toggleCart = () =>\n    async function thunk(dispatch, getState) {\n        const { app, cart } = getState();\n\n        // ensure state slices are present\n        if (!app || !cart) {\n            return;\n        }\n\n        // if the cart drawer is open, close it\n        if (app.drawer === 'cart') {\n            return dispatch(closeDrawer());\n        }\n\n        // otherwise open the cart and load its contents\n        await Promise.all([\n            dispatch(toggleDrawer('cart')),\n            dispatch(getCartDetails())\n        ]);\n    };\n\nexport const removeCart = () =>\n    async function thunk(dispatch) {\n        // Clear the cartId from local storage.\n        await clearCartId();\n\n        // Clear the cart info from the redux store.\n        await dispatch(actions.reset());\n    };\n\n/* helpers */\n\nasync function fetchCartPart({\n    cartId,\n    forceRefresh,\n    isSignedIn,\n    subResource = ''\n}) {\n    const signedInEndpoint = `/rest/V1/carts/mine/${subResource}`;\n    const guestEndpoint = `/rest/V1/guest-carts/${cartId}/${subResource}`;\n    const endpoint = isSignedIn ? signedInEndpoint : guestEndpoint;\n\n    const cache = forceRefresh ? 'reload' : 'default';\n\n    return request(endpoint, { cache });\n}\n\nexport async function getCartId(dispatch, getState) {\n    const { cart } = getState();\n\n    // reducers may be added asynchronously\n    if (!cart) {\n        return null;\n    }\n\n    // create a cart if one hasn't been created yet\n    if (!cart.cartId) {\n        await dispatch(createCart());\n    }\n\n    // retrieve app state again\n    return getState().cart.cartId;\n}\n\nexport async function retrieveCartId() {\n    return storage.getItem('cartId');\n}\n\nexport async function saveCartId(id) {\n    return storage.setItem('cartId', id);\n}\n\nexport async function clearCartId() {\n    return storage.removeItem('cartId');\n}\n\nasync function retrieveImageCache() {\n    return storage.getItem('imagesBySku') || {};\n}\n\nasync function saveImageCache(cache) {\n    return storage.setItem('imagesBySku', cache);\n}\n\n/**\n * Transforms an item payload to a shape that the REST endpoints expect.\n * When GraphQL comes online we can drop this.\n */\nfunction toRESTCartItem(cartId, payload) {\n    const { item, productType, quantity } = payload;\n\n    const cartItem = {\n        qty: quantity,\n        sku: item.sku,\n        name: item.name,\n        quote_id: cartId\n    };\n\n    if (productType === 'ConfigurableProduct') {\n        const { options, parentSku } = payload;\n\n        cartItem.sku = parentSku;\n        cartItem.product_type = 'configurable';\n        cartItem.product_option = {\n            extension_attributes: {\n                configurable_item_options: options\n            }\n        };\n    }\n\n    return cartItem;\n}\n\nexport async function writeImageToCache(item = {}) {\n    const { media_gallery_entries: media, sku } = item;\n\n    if (sku) {\n        const image = media && (media.find(m => m.position === 1) || media[0]);\n\n        if (image) {\n            const imageCache = await retrieveImageCache();\n\n            // if there is an image and it differs from cache\n            // write to cache and save in the background\n            if (imageCache[sku] !== image) {\n                imageCache[sku] = image;\n                saveImageCache(imageCache);\n\n                return image;\n            }\n        }\n    }\n}\n"],"file":"asyncActions.js"}